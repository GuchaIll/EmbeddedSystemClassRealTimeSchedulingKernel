<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.9.1"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>349 RTOS: kernel/src/syscall_thread.c File Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="doxygen_style.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">349 RTOS </a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part --><!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_dc43877d82dd332f9fb2071fcca799d6.html">kernel</a></li><li class="navelem"><a class="el" href="dir_3dd30a497388ee684638f120a124721c.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">syscall_thread.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>sys calls for thread creation and initialization  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &quot;syscall_thread.h&quot;</code><br />
<code>#include &quot;syscall_mutex.h&quot;</code><br />
<code>#include &lt;arm.h&gt;</code><br />
<code>#include &lt;mpu.h&gt;</code><br />
<code>#include &lt;systick.h&gt;</code><br />
<code>#include &lt;syscall.h&gt;</code><br />
<code>#include &lt;printk.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinterrupt__stack__frame.html">interrupt_stack_frame</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglobal__threads__info__t.html">global_threads_info_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global thread information for tracking timing, priorities, and stack limits.  <a href="structglobal__threads__info__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpushed__callee__stack__frame.html">pushed_callee_stack_frame</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack frame pushed onto MSP before initiating a context switch.  <a href="structpushed__callee__stack__frame.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTCB__t.html">TCB_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread Control Block (TCB) structure.  <a href="structTCB__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a3c88edc8d48ce7172e288f14dd6a06d6"><td class="memItemLeft" align="right" valign="top"><a id="a3c88edc8d48ce7172e288f14dd6a06d6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a3c88edc8d48ce7172e288f14dd6a06d6">XPSR_INIT</a>&#160;&#160;&#160;0x1000000</td></tr>
<tr class="memdesc:a3c88edc8d48ce7172e288f14dd6a06d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initial XPSR value, all 0s except thumb bit. <br /></td></tr>
<tr class="separator:a3c88edc8d48ce7172e288f14dd6a06d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6ea3d12a6db3f3a0b8afcb52881c2a"><td class="memItemLeft" align="right" valign="top"><a id="a8a6ea3d12a6db3f3a0b8afcb52881c2a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a8a6ea3d12a6db3f3a0b8afcb52881c2a">LR_RETURN_TO_USER_PSP</a>&#160;&#160;&#160;0xFFFFFFFD</td></tr>
<tr class="memdesc:a8a6ea3d12a6db3f3a0b8afcb52881c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt return code to user mode using PSP. <br /></td></tr>
<tr class="separator:a8a6ea3d12a6db3f3a0b8afcb52881c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf65de8424a7c25ac572b36b251eb976"><td class="memItemLeft" align="right" valign="top"><a id="abf65de8424a7c25ac572b36b251eb976"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#abf65de8424a7c25ac572b36b251eb976">LR_RETURN_TO_KERNEL_MSP</a>&#160;&#160;&#160;0xFFFFFFF1</td></tr>
<tr class="memdesc:abf65de8424a7c25ac572b36b251eb976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt return code to kernel mode using MSP. <br /></td></tr>
<tr class="separator:abf65de8424a7c25ac572b36b251eb976"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:abfd2ee26a60099efd7a5ebf6cb5fcdaf"><td class="memItemLeft" align="right" valign="top"><a id="abfd2ee26a60099efd7a5ebf6cb5fcdaf"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#abfd2ee26a60099efd7a5ebf6cb5fcdaf">thread_state_t</a> { <br />
&#160;&#160;<b>NEW</b>
, <b>READY</b>
, <b>RUNNING</b>
, <b>WAITING</b>
, <br />
&#160;&#160;<b>DONE</b>
<br />
 }</td></tr>
<tr class="memdesc:abfd2ee26a60099efd7a5ebf6cb5fcdaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of thread states. <br /></td></tr>
<tr class="separator:abfd2ee26a60099efd7a5ebf6cb5fcdaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a69a29586c6f6c64a63aeae6653bc3af0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a69a29586c6f6c64a63aeae6653bc3af0">ub_test</a> (int C, int T)</td></tr>
<tr class="memdesc:a69a29586c6f6c64a63aeae6653bc3af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the utilization bound (UB) test for thread creation.  <a href="syscall__thread_8c.html#a69a29586c6f6c64a63aeae6653bc3af0">More...</a><br /></td></tr>
<tr class="separator:a69a29586c6f6c64a63aeae6653bc3af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51cabf6c0a481d3a58cc7ee01b0bd0a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a51cabf6c0a481d3a58cc7ee01b0bd0a5">thread_scheduler</a> ()</td></tr>
<tr class="memdesc:a51cabf6c0a481d3a58cc7ee01b0bd0a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduler function to manage thread execution.  <a href="syscall__thread_8c.html#a51cabf6c0a481d3a58cc7ee01b0bd0a5">More...</a><br /></td></tr>
<tr class="separator:a51cabf6c0a481d3a58cc7ee01b0bd0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66dd67d5d707d20135483b2c17b3b89"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#ab66dd67d5d707d20135483b2c17b3b89">pendsv_c_handler</a> (void *context_ptr)</td></tr>
<tr class="memdesc:ab66dd67d5d707d20135483b2c17b3b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">PendSV handler for context switching.  <a href="syscall__thread_8c.html#ab66dd67d5d707d20135483b2c17b3b89">More...</a><br /></td></tr>
<tr class="separator:ab66dd67d5d707d20135483b2c17b3b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2434420e7d99cb09ce14d124ae11236d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a2434420e7d99cb09ce14d124ae11236d">default_idle_fn</a> ()</td></tr>
<tr class="memdesc:a2434420e7d99cb09ce14d124ae11236d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default idle function.  <a href="syscall__thread_8c.html#a2434420e7d99cb09ce14d124ae11236d">More...</a><br /></td></tr>
<tr class="separator:a2434420e7d99cb09ce14d124ae11236d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1345a2fb5a452e440b4bd2c746c4fe3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#af1345a2fb5a452e440b4bd2c746c4fe3">sys_thread_init</a> (uint32_t max_threads, uint32_t stack_size, void *idle_fn, uint32_t max_mutexes)</td></tr>
<tr class="memdesc:af1345a2fb5a452e440b4bd2c746c4fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the thread system.  <a href="syscall__thread_8c.html#af1345a2fb5a452e440b4bd2c746c4fe3">More...</a><br /></td></tr>
<tr class="separator:af1345a2fb5a452e440b4bd2c746c4fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54104218aaaba481bd42968a6045691"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#ac54104218aaaba481bd42968a6045691">sys_thread_create</a> (void *fn, uint32_t prio, uint32_t C, uint32_t T, void *vargp)</td></tr>
<tr class="memdesc:ac54104218aaaba481bd42968a6045691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new thread.  <a href="syscall__thread_8c.html#ac54104218aaaba481bd42968a6045691">More...</a><br /></td></tr>
<tr class="separator:ac54104218aaaba481bd42968a6045691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0726d2166701a485c555e6b7f7af3b60"><td class="memItemLeft" align="right" valign="top"><a id="a0726d2166701a485c555e6b7f7af3b60"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>sys_scheduler_start</b> (uint32_t frequency)</td></tr>
<tr class="separator:a0726d2166701a485c555e6b7f7af3b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4f86fe10ac2c90ce8158872aac7ce2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a8b4f86fe10ac2c90ce8158872aac7ce2">sys_get_priority</a> ()</td></tr>
<tr class="memdesc:a8b4f86fe10ac2c90ce8158872aac7ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the priority of the currently running thread.  <a href="syscall__thread_8c.html#a8b4f86fe10ac2c90ce8158872aac7ce2">More...</a><br /></td></tr>
<tr class="separator:a8b4f86fe10ac2c90ce8158872aac7ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341334c885696457b6f66bb8acda5b22"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a341334c885696457b6f66bb8acda5b22">sys_get_time</a> ()</td></tr>
<tr class="memdesc:a341334c885696457b6f66bb8acda5b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the total tick counts since the global timer has started.  <a href="syscall__thread_8c.html#a341334c885696457b6f66bb8acda5b22">More...</a><br /></td></tr>
<tr class="separator:a341334c885696457b6f66bb8acda5b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8933e910725546aa9e052369db9cf81"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#aa8933e910725546aa9e052369db9cf81">sys_thread_time</a> ()</td></tr>
<tr class="memdesc:aa8933e910725546aa9e052369db9cf81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the absolute time of the currently running thread.  <a href="syscall__thread_8c.html#aa8933e910725546aa9e052369db9cf81">More...</a><br /></td></tr>
<tr class="separator:aa8933e910725546aa9e052369db9cf81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601e5d8e922ccdec535527e8d8724d78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a601e5d8e922ccdec535527e8d8724d78">sys_thread_kill</a> ()</td></tr>
<tr class="memdesc:a601e5d8e922ccdec535527e8d8724d78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permanently deschedules the currently running thread.  <a href="syscall__thread_8c.html#a601e5d8e922ccdec535527e8d8724d78">More...</a><br /></td></tr>
<tr class="separator:a601e5d8e922ccdec535527e8d8724d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3a3fb472158a93e59df836b9935b54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a2a3a3fb472158a93e59df836b9935b54">sys_wait_until_next_period</a> ()</td></tr>
<tr class="memdesc:a2a3a3fb472158a93e59df836b9935b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current thread to wait until the next period.  <a href="syscall__thread_8c.html#a2a3a3fb472158a93e59df836b9935b54">More...</a><br /></td></tr>
<tr class="separator:a2a3a3fb472158a93e59df836b9935b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d3058e8c4464d614c9506562710e91"><td class="memItemLeft" align="right" valign="top"><a id="a12d3058e8c4464d614c9506562710e91"></a>
kmutex_t *&#160;</td><td class="memItemRight" valign="bottom"><b>sys_mutex_init</b> (uint32_t max_prio)</td></tr>
<tr class="separator:a12d3058e8c4464d614c9506562710e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a14ccbc1e43d61617b97ecd06cf65b9"><td class="memItemLeft" align="right" valign="top"><a id="a6a14ccbc1e43d61617b97ecd06cf65b9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sys_mutex_lock</b> (kmutex_t *mutex)</td></tr>
<tr class="separator:a6a14ccbc1e43d61617b97ecd06cf65b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55db4294dd5ed35ee5b2b1b1043ddbdd"><td class="memItemLeft" align="right" valign="top"><a id="a55db4294dd5ed35ee5b2b1b1043ddbdd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sys_mutex_unlock</b> (kmutex_t *mutex)</td></tr>
<tr class="separator:a55db4294dd5ed35ee5b2b1b1043ddbdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a965b457902b75612d5c4db04d78cb6e1"><td class="memItemLeft" align="right" valign="top"><a id="a965b457902b75612d5c4db04d78cb6e1"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a965b457902b75612d5c4db04d78cb6e1">__thread_u_stacks_low</a></td></tr>
<tr class="memdesc:a965b457902b75612d5c4db04d78cb6e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap high and low pointers. <br /></td></tr>
<tr class="separator:a965b457902b75612d5c4db04d78cb6e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df5a7143f4fb8f52024cc2eb04d179e"><td class="memItemLeft" align="right" valign="top"><a id="a7df5a7143f4fb8f52024cc2eb04d179e"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><b>__thread_u_stacks_top</b></td></tr>
<tr class="separator:a7df5a7143f4fb8f52024cc2eb04d179e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1e9fb5e74e0a3280d8d6b74d61146a"><td class="memItemLeft" align="right" valign="top"><a id="aed1e9fb5e74e0a3280d8d6b74d61146a"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><b>__thread_k_stacks_low</b></td></tr>
<tr class="separator:aed1e9fb5e74e0a3280d8d6b74d61146a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f42f247ccf963d377b87cf4bc2ccca"><td class="memItemLeft" align="right" valign="top"><a id="a52f42f247ccf963d377b87cf4bc2ccca"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><b>__thread_k_stacks_top</b></td></tr>
<tr class="separator:a52f42f247ccf963d377b87cf4bc2ccca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33ce2862dbb799d0a0ee16bb2d11aea"><td class="memItemLeft" align="right" valign="top"><a id="ae33ce2862dbb799d0a0ee16bb2d11aea"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>thread_kill</b></td></tr>
<tr class="separator:ae33ce2862dbb799d0a0ee16bb2d11aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187e79dd2a6a18d6bbbc4f2509eb668b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a187e79dd2a6a18d6bbbc4f2509eb668b">ub_table</a> []</td></tr>
<tr class="memdesc:a187e79dd2a6a18d6bbbc4f2509eb668b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Precalculated values for UB test.  <a href="syscall__thread_8c.html#a187e79dd2a6a18d6bbbc4f2509eb668b">More...</a><br /></td></tr>
<tr class="separator:a187e79dd2a6a18d6bbbc4f2509eb668b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e82c6af2143570727e2f0e7a2feb51"><td class="memItemLeft" align="right" valign="top"><a id="ad8e82c6af2143570727e2f0e7a2feb51"></a>
<a class="el" href="structTCB__t.html">TCB_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#ad8e82c6af2143570727e2f0e7a2feb51">TCB_ARRAY</a> [16]</td></tr>
<tr class="memdesc:ad8e82c6af2143570727e2f0e7a2feb51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of Thread Control Blocks (TCBs) for all threads. <br /></td></tr>
<tr class="separator:ad8e82c6af2143570727e2f0e7a2feb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d8bcf311e6b93798e1d4874f52c811"><td class="memItemLeft" align="right" valign="top"><a id="a55d8bcf311e6b93798e1d4874f52c811"></a>
<a class="el" href="structglobal__threads__info__t.html">global_threads_info_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a55d8bcf311e6b93798e1d4874f52c811">global_threads_info</a></td></tr>
<tr class="memdesc:a55d8bcf311e6b93798e1d4874f52c811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global structure holding thread-related information. <br /></td></tr>
<tr class="separator:a55d8bcf311e6b93798e1d4874f52c811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcac9c6e35fbfad54a6447b7ee95f54"><td class="memItemLeft" align="right" valign="top"><a id="acfcac9c6e35fbfad54a6447b7ee95f54"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>sysTickFlag</b></td></tr>
<tr class="separator:acfcac9c6e35fbfad54a6447b7ee95f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c95ea87e3847f338b8c044241375f0"><td class="memItemLeft" align="right" valign="top"><a id="a85c95ea87e3847f338b8c044241375f0"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>total_count</b></td></tr>
<tr class="separator:a85c95ea87e3847f338b8c044241375f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>sys calls for thread creation and initialization </p>
<dl class="section date"><dt>Date</dt><dd>3/24/25</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Charlie Ai and Mario Cruz </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a2434420e7d99cb09ce14d124ae11236d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2434420e7d99cb09ce14d124ae11236d">&#9670;&nbsp;</a></span>default_idle_fn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void default_idle_fn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default idle function. </p>
<p>This function is executed when no other threads are ready to run. </p>

</div>
</div>
<a id="ab66dd67d5d707d20135483b2c17b3b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab66dd67d5d707d20135483b2c17b3b89">&#9670;&nbsp;</a></span>pendsv_c_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* pendsv_c_handler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PendSV handler for context switching. </p>
<p>This function saves the current thread's context, selects the next thread to run, and restores the context of the next thread.</p>
<p>pendsv_c_handler(context_ptr)</p><ol type="1">
<li>Saves context to TCB (basically just saving the msp)</li>
<li>Calls the scheduler to return priority of the next thread to be run</li>
<li>Retrieves the msp of the next thread to be run and returns that value</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context_ptr</td><td>Pointer to the context of the current thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the context of the next thread to run. </dd></dl>
<p>You might have to alter it but the TA said we do not need to set the register individually here, could just set TCB-&gt;msp = *callee_saved_stk</p>

</div>
</div>
<a id="a8b4f86fe10ac2c90ce8158872aac7ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4f86fe10ac2c90ce8158872aac7ce2">&#9670;&nbsp;</a></span>sys_get_priority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sys_get_priority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the priority of the currently running thread. </p>
<dl class="section return"><dt>Returns</dt><dd>The priority of the currently running thread. </dd></dl>

</div>
</div>
<a id="a341334c885696457b6f66bb8acda5b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a341334c885696457b6f66bb8acda5b22">&#9670;&nbsp;</a></span>sys_get_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sys_get_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the total tick counts since the global timer has started. </p>
<dl class="section return"><dt>Returns</dt><dd>the current total tick values. </dd></dl>

</div>
</div>
<a id="ac54104218aaaba481bd42968a6045691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54104218aaaba481bd42968a6045691">&#9670;&nbsp;</a></span>sys_thread_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_thread_create </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>prio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vargp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new thread. </p>
<p>Initializes the thread's TCB, sets up its stack, and configures its computation time and period.</p>
<p>sys_thread_create(fn, prio, C, T, vargp)</p><ol type="1">
<li>Do checks to ensure that thread creation would be valid</li>
<li>Updates TCB of corresponding priority with values from inputs</li>
<li>Sets up the stack pointed to by the threads MSP (at precomputed address) to contain default values PSP (precomputed), r4 - r11, lr</li>
<li>Sets up the stack pointed to by the threads PSP with interrupt stack frame and fills it in with function pointer and vargp</li>
<li>Sets up the global thread info values to include things like appropriate thread absolute start time, and time left in period.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>Function pointer to the thread's entry function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prio</td><td>Priority of the thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>Computation time (C) in ticks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>Period (T) in ticks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vargp</td><td>Pointer to the thread's argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="af1345a2fb5a452e440b4bd2c746c4fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1345a2fb5a452e440b4bd2c746c4fe3">&#9670;&nbsp;</a></span>sys_thread_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_thread_init </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stack_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>idle_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_mutexes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the thread system. </p>
<p>Sets up the global thread information, allocates stack space, and initializes the idle thread and default thread.</p>
<p>sys_thread_init(max_threads, stack_size, idle_fn, max_mutexes</p><ol type="1">
<li>Updates global thread values such as max_threads and stack size<ol type="a">
<li>Computes all psp and msp pointers for threads to be run</li>
<li>Sets up the idle_fn with the default values at the final value of priortiy in the array (depends on max_threads)</li>
<li>Sets up interrupt stack frame for idle_fn on its psp</li>
<li>Sets up default values in the precomputed msp that contain psp and r4, etc, error code in lr.</li>
</ol>
</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max_threads</td><td>Maximum number of threads. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stack_size</td><td>Stack size for each thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idle_fn</td><td>Pointer to the idle function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_mutexes</td><td>Maximum number of mutexes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a601e5d8e922ccdec535527e8d8724d78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601e5d8e922ccdec535527e8d8724d78">&#9670;&nbsp;</a></span>sys_thread_kill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_thread_kill </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permanently deschedules the currently running thread. </p>
<p>Transitions the thread to the DONE state and selects the next thread to run. </p>

</div>
</div>
<a id="aa8933e910725546aa9e052369db9cf81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8933e910725546aa9e052369db9cf81">&#9670;&nbsp;</a></span>sys_thread_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sys_thread_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the absolute time of the currently running thread. </p>
<dl class="section return"><dt>Returns</dt><dd>The absolute time of the currently running thread. </dd></dl>

</div>
</div>
<a id="a2a3a3fb472158a93e59df836b9935b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3a3fb472158a93e59df836b9935b54">&#9670;&nbsp;</a></span>sys_wait_until_next_period()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_wait_until_next_period </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the current thread to wait until the next period. </p>
<p>Transitions the thread to the WAITING state and triggers the PendSV interrupt to invoke the scheduler. </p>

</div>
</div>
<a id="a51cabf6c0a481d3a58cc7ee01b0bd0a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51cabf6c0a481d3a58cc7ee01b0bd0a5">&#9670;&nbsp;</a></span>thread_scheduler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int thread_scheduler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduler function to manage thread execution. </p>
<p>This function reduces the computation time (C) of the currently running thread, transitions threads to the appropriate state based on their computation time and period, and selects the next thread to run.</p>
<p><a class="el" href="syscall__thread_8c.html#a51cabf6c0a481d3a58cc7ee01b0bd0a5" title="Scheduler function to manage thread execution.">thread_scheduler()</a></p><ol type="1">
<li>Reduces the compute time left of the currently running thread 2 If compute time is 0, then switch to WAITING state for the thread</li>
<li>Reduces the period time left of all the threads</li>
<li>If period time left is 0, then switch to READY state and reset the values of C time left and T time left</li>
<li>Loops through the thread array to find the closest thread to priority 0 that is READY state</li>
<li>Switches the next thread to be run's state to RUNNING and returns its priority <dl class="section return"><dt>Returns</dt><dd>The priority of the next thread to run. </dd></dl>
</li>
</ol>

</div>
</div>
<a id="a69a29586c6f6c64a63aeae6653bc3af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69a29586c6f6c64a63aeae6653bc3af0">&#9670;&nbsp;</a></span>ub_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ub_test </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the utilization bound (UB) test for thread creation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>Computation time of the new thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>Period of the new thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the thread passes the UB test, -1 otherwise. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a187e79dd2a6a18d6bbbc4f2509eb668b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187e79dd2a6a18d6bbbc4f2509eb668b">&#9670;&nbsp;</a></span>ub_table</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float ub_table[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">  0.000, 1.000, .8284, .7798, .7568,</div>
<div class="line">  .7435, .7348, .7286, .7241, .7205,</div>
<div class="line">  .7177, .7155, .7136, .7119, .7106,</div>
<div class="line">  .7094, .7083, .7075, .7066, .7059,</div>
<div class="line">  .7052, .7047, .7042, .7037, .7033,</div>
<div class="line">  .7028, .7025, .7021, .7018, .7015,</div>
<div class="line">  .7012, .7009</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>Precalculated values for UB test. </p>
<p>ub_table: </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
</body>
</html>
